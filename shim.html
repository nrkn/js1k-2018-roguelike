<!doctype html>
<html>
  <!-- note: your demo in this shim runs in an iframe with this content: https://gist.github.com/qfox/3cccc4f36c8319e09bb7 -->
  <!--
  (c) js1k.com 2018
  Note: submissions belong to their respective owner, do not copy without their consent
  -->
  <head>
    <meta charset="utf-8">
    <meta
  http-equiv="Content-Security-Policy"
  content="
    connect-src              'none'                                                             ;
    default-src              'none'                                                             ;
    font-src                 'none'                                                             ;
    frame-src                'self'            data:                                            ;
    child-src                'self'            data:                                            ;
    img-src                  'self'            data:            ssl.google-analytics.com        ;
    media-src                data:                                                              ;
    object-src               data:                                                              ;
    style-src                'self'            data:            'unsafe-inline'                 ;
    script-src               'unsafe-inline'   'unsafe-eval'    www.google-analytics.com        ;
  "
  help="please report csp-related problems to valid demos!"
>

    <title>JS1k 2018 - NNNN - TITLE</title>
    <meta name="author" content="YOU">
    <link rel="icon" type="image/png" href="https://js1k.com/favicon.png">
    <link rel="canonical" href="https://js1k.com/2018-coins/demo/NNNN">
    <link rel="shortlink" href="https://js1k.com/NNNN">
    <script>
      // GA
    </script>
    <style>
      /* https://qfox.nl/notes/333 */
      body,html,iframe{margin:0;padding:0;border:0;width:100%;height:100%}
      iframe{position:absolute;top:0;left:0;padding-top:50px;box-sizing:border-box}
      header{position:relative;z-index:1;height:47px;padding-top:2px;border-bottom:1px solid #000;box-shadow:0 -10px 25px #ccc inset;background-color:#eee}
      aside,div,h1,p{overflow:hidden;white-space:nowrap;text-overflow:ellipsis;text-align:center;font-size:16px;font-weight:inherit;line-height:22px;padding:0;margin:0;cursor:default}
      aside,h1{display:inline}
      a{color:#000;text-decoration:none;border-bottom:1px dashed #000}
      a:hover{border-bottom:1px solid red}
      a[href="0"]{text-decoration:line-through;pointer-events:none;border-bottom:0;color:#ccc}
      .button{float:left;width:40px;height:40px;line-height:40px;text-align:center;padding:0;margin:2px 0 0 10px;border:1px solid #888;border-color:#ddd #888 #888 #ddd;font-family:sans-serif;font-size:30px;font-weight:700;cursor:pointer}
      .button:hover{color:red;border-bottom-color:#888}
      .r{margin-right:10px}
      time{display:none}
    </style>
  </head>
  <body>
    <header>
      <div>
        <h1>
          <a href="https://js1k.com/">JS1k</a>
          <a href="https://js1k.com/2018-coins">2018</a>
          <strong></strong> demo
          &mdash;
          "TITLE" by YOU
        </h1>
        <p>
          <em>
            FIRST PART OF YOUR DESC GOES HERE
          </em>
        </p>
        <aside>
          &mdash;
          1024 bytes
          &mdash;
          <a href="https://js1k.com/2018-coins/details/NNNN">demo details</a>
          &mdash;
          <a href="https://js1k.com/2018-coins/demos">list of demos</a>
          &mdash;
          <a href="https://js1k.com/NNNN" title="short link for your mobile devices" rel="nofollow">js1k.com/NNNN</a>
          <time datetime="NOW" pubdate>NOW</time>
        </aside>
      </div>

      <a href="500" class="button p">&Larr;</a>
      <a href="502" class="button n">&Rarr;</a>
    </header>

    <script type="shim">
      // this is the SHIM (will be ran in the context of the iframe...)

      // unprefix some popular vendor prefixed things (but stick to their original name)
      iwin.AudioContext = iwin.AudioContext || iwin.webkitAudioContext; // ios8 unmutes audio only during the first user triggered event with sound
      iwin.requestAnimationFrame = iwin.requestAnimationFrame || iwin.mozRequestAnimationFrame || iwin.webkitRequestAnimationFrame || iwin.msRequestAnimationFrame || function(f){ iwin.setTimeout(f, 1000/30); };
      canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock || canvas.webkitRequestPointerLock;
      navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
      if (typeof OscillatorNode !== 'undefined' && OscillatorNode.prototype) {
        OscillatorNode.prototype.start = OscillatorNode.prototype.start || OscillatorNode.prototype.noteOn;
        OscillatorNode.prototype.stop = OscillatorNode.prototype.stop || OscillatorNode.prototype.noteOff;
      }

      a = canvas;
      b = idoc.body;
      d = idoc.document;

      if (!TOKEN_WEBGL) iwin.c = canvas.getContext('2d');
      else iwin.g = (function () {
        iwin.onorientationchange = iwin.onresize = null;
        try {
          var o = { antialias: true, stencil: true };
          var gl = canvas.getContext('webgl', o) || canvas.getContext('experimental-webgl', o);

          // keep in scope, must not be garbage collected
          iwin.__glExts =
            [ 'OES_texture_float', 'OES_texture_float_linear', 'OES_standard_derivatives',
              'EXT_texture_filter_anisotropic', 'MOZ_EXT_texture_filter_anisotropic', 'WEBKIT_EXT_texture_filter_anisotropic',
              'WEBGL_compressed_texture_s3tc', 'MOZ_WEBGL_compressed_texture_s3tc', 'WEBKIT_WEBGL_compressed_texture_s3tc'
            ].map(function(ext) {
                return gl.getExtension(ext);
              });
        } catch (e) {
          idoc.body.innerHTML = 'WebGL not supported.';
          iwin.a=iwin.b=iwin.c=iwin.d=null;
          throw e;
        }

        return gl;
      })();
    </script>
    <script>
      // submission form configurables:

      // enable canvas shim at all? (2d/3d). other settings are ignored if this is false.
      var TOKEN_CANVAS_SHIM = true;
      // true enables webgl shim (exposes `g`), false enables canvas shim (exposes `c`)
      var TOKEN_WEBGL = false;
      // px, 0 means always 100%
      var TOKEN_MAX_WIDTH = 0;
      // px, 0 means always 100%
      var TOKEN_MAX_HEIGHT = 0;
      // should the size be smaller than specified if viewport is smaller?
      var TOKEN_MAX_100P = true;
      // only if width<100%
      var TOKEN_CENTER_CANVAS = false;
      // "press" reload button on orientation change?
      var TOKEN_RELOAD_ONORIENTATIONCHANGE = true;
    </script>
    <script type="demo">
        'use strict'

        /*
          This function closure is just for the minifier so it knows it's OK to rename
          variables - can remove before packing
        */
        let G = () => {
          /*
            Constants - these will get inlined by the minifier but make it a lot more
            readable
          */
          /*
            These are indices into tiles
          */
          let X = 0
          let Y = 1
          let TILE_TYPE = 2
          let HP = 3
          let CHAR = 4
          /*
            Tile types
          */
          let TILE_TYPE_PLAYER = 0
          let TILE_TYPE_MONSTER = 1
          let TILE_TYPE_STAIRS_DOWN = 2
          let TILE_TYPE_FLOOR = 3
          let TILE_TYPE_POTION = 4
          /*
            Indices into level structure
          */
          let FLOORS = 0
          let MOBS = 1
          /*
            Symbols
          */
          let CHAR_PLAYER = '@'
          let CHAR_WALL = '#'
          let CHAR_FLOOR = '.'
          let CHAR_MONSTER = 'm'
          let CHAR_STAIRS_DOWN = '>'
          let CHAR_STAIRS_UP = '<'
          let CHAR_POTION = '!'
          
          /*
            Dungeon settings
        
            width and height are the bounds for randomly placing initial points for 
            rooms, but aside from placing those initial points, no bounding checks are 
            done, to save bytes - the draw algorithm and movement checks are designed 
            around points being potentially at any coordinate including negative ones
        
            minRoomSize and maxRoomSize are the min/max in each direction from the 
            "center" of a room and not the total min/max size for a room
          */  
          let width = 20
          let height = 20
          let minRoomSize = 1
          let maxRoomSize = 10
          let roomCount = 4
          let monsterCount = 4
          let playerStartHP = 10
        
          let debug = false
        
          if( debug ){
            playerStartHP = 1000
          }
        
          /*
            Bog-standard exlusive max based random integer function
          */
          let randInt = exclusiveMax => ( Math.random() * exclusiveMax ) | 0
              
          /*
            View settings
          */
          let viewSize = 25
          let viewOff = 12 // ( viewSize - 1 ) / 2
        
          /*
            Level state
          */
          let currentLevel = 0
          let levels = []
          let player = [ 
            randInt( width ), randInt( height ), 
            TILE_TYPE_PLAYER, playerStartHP, CHAR_PLAYER
          ]
          
          /*
            Is there a tile in collection that collides with the provided point?
            
            Also check the hit points and don't consider "dead" tiles for collision
            
            This lets us kill monsters without deleting them from the array, which is
            expensive - we just don't collide with or draw dead things
        
            Has strange side effect whereby floors etc need HP in order to be drawn haha
        
            Same as points.find( ... ) but reuse for(;;) syntax for better packing
          */
          let collides = ( tiles, point ) => {
            for( let i = 0; i < tiles.length; i++ ){
              if( 
                tiles[ i ][ HP ] && 
                point[ X ] == tiles[ i ][ X ] && 
                point[ Y ] == tiles[ i ][ Y ] 
              ) return tiles[ i ]
            }
          }
        
          let towardsOrDirection = ( p1, p2, direction, towards ) => {
            if( towards ){
              if( p1[ X ] < p2[ X ] ){
                p2[ X ]--
              } 
              else if( p1[ X ] > p2[ X ] ){
                p2[ X ]++
              } 
              else if( p1[ Y ] < p2[ Y ] ){
                p2[ Y ]--        
              } 
              else if( p1[ Y ] > p2[ Y ] ){
                p2[ Y ]++
              }
            } else {
              //up
              if( direction == 1 ){
                p2[ Y ]--
              } 
              //right
              else if( direction == 2 ){
                p2[ X ]++
              } 
              //down
              else if( direction == 3 ){
                p2[ Y ]++
              } 
              //left
              else{
                p2[ X ]--
              }
            }    
          }
        
          /*
            Dungeon generator
          */
          let Dungeon = () => { 
            /*
              Allow moving up stairs
            */
            // if( levels[ currentLevel ] ) return
           
            let floors = [
              [ player[ X ], player[ Y ], TILE_TYPE_FLOOR, 1, CHAR_FLOOR ]
            ]
            let mobs = [ player ]
        
            let levelWidth = randInt( currentLevel * width ) + width
            let levelHeight = randInt( currentLevel * height ) + height
            let levelRooms = randInt( currentLevel * roomCount ) + roomCount
            let levelMonsters = randInt( currentLevel * monsterCount ) + monsterCount
            let levelPotions = randInt( currentLevel * monsterCount ) + monsterCount
        
            /*
              Add a new mob, even stairs are mobs to save bytes
            */
            let addMob = ( tileType, hp, ch ) => {
              let mob = [ 
                randInt( levelWidth ), randInt( levelHeight ), 
                tileType, hp, ch 
              ]
              
              /*
                Has to collide with a floor tile to be on map, but also has to be the
                only mob at this point on the map
              */
              if( 
                collides( levels[ currentLevel ][ FLOORS ], mob ) && 
                !collides( levels[ currentLevel ][ MOBS ], mob ) 
              ){
                levels[ currentLevel ][ MOBS ].push( mob )
        
                return mob
              } 
              
              /*
                Call recursively if couldn't place, saves a while loop
              */
              return addMob( tileType, hp, ch )    
            }
            
            // draw an L-shaped corridor between these two points
            let connect = ( p1, p2 ) => {     
              if( !collides( floors, p2 ) ){
                floors.push(
                  [ p2[ X ], p2[ Y ], TILE_TYPE_FLOOR, 1, CHAR_FLOOR ]
                )
              }
        
              if( p1[ X ] == p2[ X ] && p1[ Y ] == p2[ Y ] ) return
        
              let direction = randInt( 4 )
        
              towardsOrDirection( p1, p2, direction, !randInt( 3 ) )
        
              connect( p1, p2 )
            } 
          
            for( let i = 0; i < levelRooms; i++ ){
              connect( floors[ randInt( floors.length ) ], [ randInt( levelWidth ), randInt( levelHeight ) ] )
            }
            
            levels[ currentLevel ] = [ floors, mobs ]
        
            // would be nice to not have stairs in corridors
            addMob( TILE_TYPE_STAIRS_DOWN, 1, CHAR_STAIRS_DOWN )
        
            for( let i = 0; i < levelMonsters; i++ ){
              addMob( TILE_TYPE_MONSTER, 1, CHAR_MONSTER )
            }
        
            for( let i = 0; i < levelPotions; i++ ){
              addMob( TILE_TYPE_POTION, 1, CHAR_POTION )
            }
          } 
        
          /*
            Almost like a raycaster, we create a viewport centered on the player and
            use the collision algorithm to decide whether to draw or not for each tile, 
            gets rid of tedious bounds checking etc - super inefficient for the CPU but 
            good for byte count of code
          */
          let draw = () => {
            /*
              canvas default is 10pt text
            */
            let textSize = 10
        
            /*
              cheapest way to clear canvas?
            */
            a.width = a.width
        
            for( let vY = 0; vY < viewSize; vY++ ){
              for( let vX = 0; vX < viewSize; vX++ ){
                let x = player[ X ] - viewOff + vX
                let y = player[ Y ] - viewOff + vY
        
                let current = 
                  collides( levels[ currentLevel ][ MOBS ], [ x, y ] ) || 
                  collides( levels[ currentLevel ][ FLOORS ], [ x, y ] )
        
                /*
                  A wall - # - is just an absence of anything else
                */
                c.fillText( 
                  currentLevel > 9 ?
                  '*' :
                  player[ HP ] < 1 ?
                  'X' :
                  current ? 
                  current[ CHAR ] : 
                  CHAR_WALL, 
                  vX * textSize, 
                  vY * textSize 
                )
              }
            }
            c.fillText( 'L ' + currentLevel + ' HP ' + player[ HP ], 0, viewSize * textSize )
          }
        
          /*
            Movement for both payers and monsters
          */
          let move = ( mob, direction ) => {    
            /*
              set the position we're going to move to to the position we're already at
            */
            let targetPoint = [ mob[ X ], mob[ Y ] ]
        
            /*
              Monsters, one in five chance doesn't move towards player, otherwise try to
              move closer - the if/else structure here creates very predictable movement
              but is also very cheap - the chance not to move towards player helps to
              stop monsters getting permanently stuck
            */
        
            towardsOrDirection( player, targetPoint, direction, mob[ TILE_TYPE ] == TILE_TYPE_MONSTER && randInt( 5 ) )
        
            /*
              See if anything is at the point we tried to move to
            */
            let currentTile = collides( levels[ currentLevel ][ MOBS ], targetPoint )
        
            /*
              If we're a monster and the tile we tried to move to has a player on it,
              try to hit them instead of moving there
            */
            if( 
              currentTile && mob[ TILE_TYPE ] == TILE_TYPE_MONSTER && 
              currentTile[ TILE_TYPE ] == TILE_TYPE_PLAYER && randInt( 2 ) 
            ){
              currentTile[ HP ]--
            } 
            /*
              Ditto for player moving onto monster
            */
            else if( 
              currentTile && mob[ TILE_TYPE ] == TILE_TYPE_PLAYER && 
              currentTile[ TILE_TYPE ] == TILE_TYPE_MONSTER && randInt( 2 ) 
            ){
              currentTile[ HP ]--
            }
            /*
              Go down stairs
            */
            else if( 
              currentTile && mob[ TILE_TYPE ] == TILE_TYPE_PLAYER &&
              currentTile[ TILE_TYPE ] == TILE_TYPE_STAIRS_DOWN 
            ){
              currentLevel++
              Dungeon()
            }
            /*
              Potion - note that monsters can also pick up potions - to change, check
              if mob is player
            */
            else if( currentTile && currentTile[ TILE_TYPE ] == TILE_TYPE_POTION ){
              mob[ HP ]++
              currentTile[ HP ]--
            }
            /*
              If this is a floor tile and no mobs were here, we can move
            */
            else if( 
              collides( levels[ currentLevel ][ FLOORS ], targetPoint ) && !currentTile 
            ){
              mob[ X ] = targetPoint[ X ]
              mob[ Y ] = targetPoint[ Y ]
            } 
          }
          
          b.onkeydown = e => {
            /*
              Player moves first, slight advantage
            */
            move( player, e.which - 37 )
            
            /*
              Search the mobs for monsters, try to randomly move any that aren't dead
              Monsters prefer to move towards player but there's a chance they'll use
              this passed in random "keycode" instead
            */
            for( let i = 0; i < levels[ currentLevel ][ MOBS ].length; i++ ){
              if( 
                levels[ currentLevel ][ MOBS ][ i ][ HP ] && 
                levels[ currentLevel ][ MOBS ][ i ][ TILE_TYPE ] == TILE_TYPE_MONSTER 
              ) move( levels[ currentLevel ][ MOBS ][ i ], randInt( 4 ) )
            }
        
            draw()
            /*
            consider adding chance to spawn a monster on movement
            */
          }
        
          Dungeon()
          draw()    
        }
        
        G()
      
    </script>
    <script>
      (function(){var doc=document;var header=doc.getElementsByTagName("header")[0];var firstChild=header.firstChild;var p=doc.getElementsByClassName("p")[0];
      var n=doc.getElementsByClassName("n")[0];header.insertBefore(p,firstChild);header.insertBefore(n,firstChild);header.appendChild(doc.getElementsByTagName
      ("p")[0])})();(function reload(fullscreen){var doc=document;var header=doc.getElementsByTagName("header")[0];var iframe=doc.createElement("iframe");doc.
      body.appendChild(iframe);var iwin=iframe.contentWindow;var idoc=iframe.contentDocument;idoc.open();idoc.close();idoc.write("<!doctype html>"+'<html st'+
      'yle="margin: 0; padding: 0; border: 0;'+(TOKEN_CANVAS_SHIM?' width: 100%; height: 100%;':'')+'">'+"<head>"+'<meta charset="utf-8">'+'<body style="mar'+
      'gin: 0; padding: 0; border: 0;'+(TOKEN_CANVAS_SHIM?' width: 100%; height: 100%;':'')+'">'+(TOKEN_CANVAS_SHIM?'<canvas style="display: block;'+(
      TOKEN_CENTER_CANVAS?" margin: auto;":"")+'"></canvas>':"")+"");if(TOKEN_CANVAS_SHIM){var canvas=idoc.getElementsByTagName("canvas")[0];var cs=canvas.style
      ;idoc.body.clientWidth;cs.width=(canvas.width=Math.max(Math.min(TOKEN_MAX_WIDTH||innerWidth,innerWidth),0)||0)+"px";cs.height=(canvas.height=Math.max(
      Math.min(TOKEN_MAX_HEIGHT||innerHeight-50,innerHeight-50),0)||0)+"px"}if(TOKEN_RELOAD_ONORIENTATIONCHANGE)onorientationchange=reloadClick;iwin.AudioContext
      =iwin.AudioContext||iwin.webkitAudioContext;iwin.requestAnimationFrame=iwin.requestAnimationFrame||iwin.mozRequestAnimationFrame||iwin.
      webkitRequestAnimationFrame||iwin.msRequestAnimationFrame||function(f){iwin.setTimeout(f,1E3/30)};if(TOKEN_CANVAS_SHIM)canvas.requestPointerLock=canvas.
      requestPointerLock||canvas.mozRequestPointerLock||canvas.webkitRequestPointerLock;idoc.body.requestPointerLock=idoc.body.requestPointerLock||idoc.body.
      mozRequestPointerLock||idoc.body.webkitRequestPointerLock;navigator.getUserMedia=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.
      mozGetUserMedia||navigator.msGetUserMedia;var iwo=iwin.OscillatorNode&&iwin.OscillatorNode.prototype;iwo&&(iwo.start=iwo.start||iwo.noteOn)&&(iwo.stop=iwo
      .stop||iwo.noteOff);if(TOKEN_CANVAS_SHIM)iwin.a=canvas;iwin.b=idoc.body;d=idoc;if(TOKEN_CANVAS_SHIM){if(!TOKEN_WEBGL)iwin.c=canvas.getContext("2d");if(
      TOKEN_WEBGL)iwin.g=function(){iwin.onorientationchange=iwin.onresize=null;try{var o={antialias:true,stencil:true};var gl=canvas.getContext("webgl",o)||
      canvas.getContext("experimental-webgl",o);iwin.__glExts=["OES_texture_float","OES_texture_float_linear","OES_standard_derivatives","EXT_texture_filter_"+
      "anisotropic","MOZ_EXT_texture_filter_anisotropic","WEBKIT_EXT_texture_filter_anisotropic","WEBGL_compressed_texture_s3tc","MOZ_WEBGL_compressed_textur"+
      "e_s3tc","WEBKIT_WEBGL_compressed_texture_s3tc"].map(function(ext){return gl.getExtension(ext)})}catch(e){idoc.body.innerHTML="WebGL not supported.";iwin
      .a=iwin.b=iwin.c=iwin.d=null;throw e;}return gl}()}var demo=idoc.createElement("script");demo.textContent=doc.querySelector('script[type="demo"]').
      textContent;idoc.body.appendChild(demo);idoc.close();iframe.contentWindow.focus();var firstLine=doc.getElementsByTagName("div")[0];function reloadClick(b)
      {doc.body.removeChild(iframe);r.parentElement.removeChild(r);iframe=null;r=null;idoc=null;header=null;reload(b)}window.reload=reloadClick;var r=doc.
      createElement("div");r.innerHTML="&#8635;";r.className="button r";r.title="restart just the demo (local, without remote fetch)";r.onclick=reloadClick;
      header.insertBefore(r,firstLine)})();
    </script>
  </body>
</html>
