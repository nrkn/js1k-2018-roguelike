<!doctype html>
<html>
  <!-- note: your demo in this shim runs in an iframe with this content: https://gist.github.com/qfox/3cccc4f36c8319e09bb7 -->
  <!--
  (c) js1k.com 2018
  Note: submissions belong to their respective owner, do not copy without their consent
  -->
  <head>
    <meta charset="utf-8">
    <meta
  http-equiv="Content-Security-Policy"
  content="
    connect-src              'none'                                                             ;
    default-src              'none'                                                             ;
    font-src                 'none'                                                             ;
    frame-src                'self'            data:                                            ;
    child-src                'self'            data:                                            ;
    img-src                  'self'            data:            ssl.google-analytics.com        ;
    media-src                data:                                                              ;
    object-src               data:                                                              ;
    style-src                'self'            data:            'unsafe-inline'                 ;
    script-src               'unsafe-inline'   'unsafe-eval'    www.google-analytics.com        ;
  "
  help="please report csp-related problems to valid demos!"
>

    <title>JS1k 2018 - NNNN - TITLE</title>
    <meta name="author" content="YOU">
    <link rel="icon" type="image/png" href="https://js1k.com/favicon.png">
    <link rel="canonical" href="https://js1k.com/2018-coins/demo/NNNN">
    <link rel="shortlink" href="https://js1k.com/NNNN">
    <script>
      // GA
    </script>
    <style>
      /* https://qfox.nl/notes/333 */
      body,html,iframe{margin:0;padding:0;border:0;width:100%;height:100%}
      iframe{position:absolute;top:0;left:0;padding-top:50px;box-sizing:border-box}
      header{position:relative;z-index:1;height:47px;padding-top:2px;border-bottom:1px solid #000;box-shadow:0 -10px 25px #ccc inset;background-color:#eee}
      aside,div,h1,p{overflow:hidden;white-space:nowrap;text-overflow:ellipsis;text-align:center;font-size:16px;font-weight:inherit;line-height:22px;padding:0;margin:0;cursor:default}
      aside,h1{display:inline}
      a{color:#000;text-decoration:none;border-bottom:1px dashed #000}
      a:hover{border-bottom:1px solid red}
      a[href="0"]{text-decoration:line-through;pointer-events:none;border-bottom:0;color:#ccc}
      .button{float:left;width:40px;height:40px;line-height:40px;text-align:center;padding:0;margin:2px 0 0 10px;border:1px solid #888;border-color:#ddd #888 #888 #ddd;font-family:sans-serif;font-size:30px;font-weight:700;cursor:pointer}
      .button:hover{color:red;border-bottom-color:#888}
      .r{margin-right:10px}
      time{display:none}
    </style>
  </head>
  <body>
    <header>
      <div>
        <h1>
          <a href="https://js1k.com/">JS1k</a>
          <a href="https://js1k.com/2018-coins">2018</a>
          <strong></strong> demo
          &mdash;
          "TITLE" by YOU
        </h1>
        <p>
          <em>
            FIRST PART OF YOUR DESC GOES HERE
          </em>
        </p>
        <aside>
          &mdash;
          1024 bytes
          &mdash;
          <a href="https://js1k.com/2018-coins/details/NNNN">demo details</a>
          &mdash;
          <a href="https://js1k.com/2018-coins/demos">list of demos</a>
          &mdash;
          <a href="https://js1k.com/NNNN" title="short link for your mobile devices" rel="nofollow">js1k.com/NNNN</a>
          <time datetime="NOW" pubdate>NOW</time>
        </aside>
      </div>

      <a href="500" class="button p">&Larr;</a>
      <a href="502" class="button n">&Rarr;</a>
    </header>

    <script type="shim">
      // this is the SHIM (will be ran in the context of the iframe...)

      // unprefix some popular vendor prefixed things (but stick to their original name)
      iwin.AudioContext = iwin.AudioContext || iwin.webkitAudioContext; // ios8 unmutes audio only during the first user triggered event with sound
      iwin.requestAnimationFrame = iwin.requestAnimationFrame || iwin.mozRequestAnimationFrame || iwin.webkitRequestAnimationFrame || iwin.msRequestAnimationFrame || function(f){ iwin.setTimeout(f, 1000/30); };
      canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock || canvas.webkitRequestPointerLock;
      navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
      if (typeof OscillatorNode !== 'undefined' && OscillatorNode.prototype) {
        OscillatorNode.prototype.start = OscillatorNode.prototype.start || OscillatorNode.prototype.noteOn;
        OscillatorNode.prototype.stop = OscillatorNode.prototype.stop || OscillatorNode.prototype.noteOff;
      }

      a = canvas;
      b = idoc.body;
      d = idoc.document;

      if (!TOKEN_WEBGL) iwin.c = canvas.getContext('2d');
      else iwin.g = (function () {
        iwin.onorientationchange = iwin.onresize = null;
        try {
          var o = { antialias: true, stencil: true };
          var gl = canvas.getContext('webgl', o) || canvas.getContext('experimental-webgl', o);

          // keep in scope, must not be garbage collected
          iwin.__glExts =
            [ 'OES_texture_float', 'OES_texture_float_linear', 'OES_standard_derivatives',
              'EXT_texture_filter_anisotropic', 'MOZ_EXT_texture_filter_anisotropic', 'WEBKIT_EXT_texture_filter_anisotropic',
              'WEBGL_compressed_texture_s3tc', 'MOZ_WEBGL_compressed_texture_s3tc', 'WEBKIT_WEBGL_compressed_texture_s3tc'
            ].map(function(ext) {
                return gl.getExtension(ext);
              });
        } catch (e) {
          idoc.body.innerHTML = 'WebGL not supported.';
          iwin.a=iwin.b=iwin.c=iwin.d=null;
          throw e;
        }

        return gl;
      })();
    </script>
    <script>
      // submission form configurables:

      // enable canvas shim at all? (2d/3d). other settings are ignored if this is false.
      var TOKEN_CANVAS_SHIM = true;
      // true enables webgl shim (exposes `g`), false enables canvas shim (exposes `c`)
      var TOKEN_WEBGL = false;
      // px, 0 means always 100%
      var TOKEN_MAX_WIDTH = 0;
      // px, 0 means always 100%
      var TOKEN_MAX_HEIGHT = 0;
      // should the size be smaller than specified if viewport is smaller?
      var TOKEN_MAX_100P = true;
      // only if width<100%
      var TOKEN_CENTER_CANVAS = false;
      // "press" reload button on orientation change?
      var TOKEN_RELOAD_ONORIENTATIONCHANGE = true;
    </script>
    <script type="demo">
      'use strict'

/*
  This function closure is just for the minifier so it knows it's OK to rename
  variables - can remove before packing
*/
'use strict'

/*
  This function closure is just for the minifier so it knows it's OK to rename
  variables - can remove before packing
*/
let G = () => {
  /*
    Constants - these will get inlined by the minifier but make it a lot more
    readable
  */
  /*
    These are indices into tiles
  */
  let X = 0
  let Y = 1
  let TILE_TYPE = 2
  let HP = 3
  let CHAR = 4
  /*
    Tile types
  */
  let TILE_TYPE_PLAYER = 0
  let TILE_TYPE_MONSTER = 1
  let TILE_TYPE_STAIRS_DOWN = 2
  let TILE_TYPE_FLOOR = 3
  /*
    Indices into level structure
  */
  let FLOORS = 0
  let MOBS = 1
  /*
    Symbols
  */
  let CHAR_PLAYER = '@'
  let CHAR_WALL = '#'
  let CHAR_FLOOR = '.'
  let CHAR_MONSTER = 'm'
  let CHAR_STAIRS_DOWN = '>'
  let CHAR_STAIRS_UP = '<'
  let CHAR_HEAL = '!'
  
  /*
    Dungeon settings

    width and height are the bounds for randomly placing initial points for 
    rooms, but aside from placing those initial points, no bounding checks are 
    done, to save bytes - the draw algorithm and movement checks are designed 
    around points being potentially at any coordinate including negative ones

    minRoomSize and maxRoomSize are the min/max in each direction from the 
    "center" of a room and not the total min/max size for a room
  */  
  let width = 50
  let height = 50
  let minRoomSize = 1
  let maxRoomSize = 10
  let roomCount = 5
  let monsterCount = 5
  let playerStartHP = 20

  /*
    Bog-standard exlusive max based random integer function
  */
  let randInt = exclusiveMax => ( Math.random() * exclusiveMax ) | 0
      
  /*
    View settings
  */
  let viewSize = 25
  let viewOff = 12 // ( viewSize - 1 ) / 2

  /*
    Level state
  */
  let currentLevel = 0
  let levels = []
  let player = [ 
    randInt( width ), randInt( height ), 
    TILE_TYPE_PLAYER, playerStartHP, CHAR_PLAYER
  ]
  
  /*
    Is there a tile in collection that collides with the provided point?
    
    Also check the hit points and don't consider "dead" tiles for collision
    
    This lets us kill monsters without deleting them from the array, which is
    expensive - we just don't collide with or draw dead things

    Has strange side effect whereby floors etc need HP in order to be drawn haha

    Same as points.find( ... ) but reuse for(;;) syntax for better packing
  */
  let collides = ( tiles, point ) => {
    for( let i = 0; i < tiles.length; i++ ){
      if( 
        tiles[ i ][ HP ] && 
        point[ X ] === tiles[ i ][ X ] && 
        point[ Y ] === tiles[ i ][ Y ] 
      ) return tiles[ i ]
    }
  }

  /*
    Dungeon generator
  */
  let Dungeon = () => { 
    /*
      Allow moving up stairs
    */
    // if( levels[ currentLevel ] ) return
   
    let floors = []
    let mobs = [ player ]

    let levelWidth = randInt( currentLevel * 25 ) + width
    let levelHeight = randInt( currentLevel * 25 ) + height
    let levelRooms = randInt( currentLevel * roomCount ) + roomCount
    let levelMonsters = randInt( currentLevel * monsterCount ) + monsterCount

    /*
      Add a new mob, even stairs are mobs to save bytes
    */
    let addMob = ( tileType, hp, ch ) => {
      let mob = [ 
        randInt( levelWidth ), randInt( levelHeight ), 
        tileType, hp, ch 
      ]
      
      /*
        Has to collide with a floor tile to be on map, but also has to be the
        only mob at this point on the map
      */
      if( 
        collides( levels[ currentLevel ][ FLOORS ], mob ) && 
        !collides( levels[ currentLevel ][ MOBS ], mob ) 
      ){
        levels[ currentLevel ][ MOBS ].push( mob )

        return mob
      } 
      
      /*
        Call recursively if couldn't place, saves a while loop
      */
      return addMob( tileType, hp, ch )    
    }

    let drawRect = ( p1, p2 ) => {
      /*
        If we end up using Math.min/Math.max elsewhere it may be shorter to use 
        here too, but otherwise this ternary of horror packs better

        We have to sort the points because when we're connecting two random
        points we don't know if the second one is in the correct order

        We use <= rather than < because it allows you to reuse drawRect to also
        draw lines, saving an extra function
      */
      for( 
        let y = ( p1[ Y ] < p2[ Y ] ? p1[ Y ] : p2[ Y ] ); 
        y <= (  p1[ Y ] < p2[ Y ] ? p2[ Y ] : p1[ Y ] ); 
        y++ 
      ){
        for( 
          let x = ( p1[ X ] < p2[ X ] ? p1[ X ] : p2[ X ] ); 
          x <= (  p1[ X ] < p2[ X ] ? p2[ X ] : p1[ X ] ); 
          x++ 
        ){
          /*
            Even a floor has to have HP to get drawn
          */
          floors.push( [ x, y, TILE_TYPE_FLOOR, 1, CHAR_FLOOR ] )          
        }
      }
    }
    
    // draw an L-shaped corridor between these two points
    let connect = ( p1, p2 ) => {
      drawRect( [ p1[ X ], p1[ Y ] ], [ p1[ X ], p2[ Y ] ] )
      drawRect( [ p1[ X ], p2[ Y ] ], [ p2[ X ], p2[ Y ] ] )
    } 
  
    /*
      For each room, pick a new point at random. It can be one that's already a 
      corridor or room, aside from being cheaper in bytes, it makes for more
      interesting shaped rooms if some overlap. Then connect this point randomly
      to a point already on the map to ensure we have no disconnected rooms,
      then draw a random rectangle over the top of this point to make the room
    */
    for( let i = 0; i < levelRooms; i++ ){
      /*
        Start with player
      */
      let p = 
        i === 0 ? 
        [ player[ X ], player[ Y ] ] :  // can just use player here?
        [ randInt( levelWidth ), randInt( levelHeight ) ]
    
      if( floors.length ){
        connect( p, floors[ randInt( floors.length ) ] )
      }
    
      drawRect( 
        [ 
          p[ X ] - ( randInt( maxRoomSize ) + minRoomSize ),
          p[ Y ] - ( randInt( maxRoomSize ) + minRoomSize )
        ], 
        [ 
          p[ X ] + ( randInt( maxRoomSize ) + minRoomSize ),
          p[ Y ] + ( randInt( maxRoomSize ) + minRoomSize )
        ] 
      )
    }
    
    levels[ currentLevel ] = [ floors, mobs ]

    // would be nice to not have stairs in corridors
    addMob( TILE_TYPE_STAIRS_DOWN, 1, CHAR_STAIRS_DOWN )

    for( let i = 0; i < levelMonsters; i++ ){
      addMob( TILE_TYPE_MONSTER, 1, CHAR_MONSTER )
    }
  } 

  /*
    Almost like a raycaster, we create a viewport centered on the player and
    use the collision algorithm to decide whether to draw or not for each tile, 
    gets rid of tedious bounds checking etc - super inefficient for the CPU but 
    good for byte count of code
  */
  let draw = () => {
    /*
      canvas default is 10pt text
    */
    let textSize = 10

    /*
      cheapest way to clear canvas?
    */
    a.width = a.width

    for( let vY = 0; vY < viewSize; vY++ ){
      for( let vX = 0; vX < viewSize; vX++ ){
        let x = player[ X ] - viewOff + vX
        let y = player[ Y ] - viewOff + vY

        let current = 
          collides( levels[ currentLevel ][ MOBS ], [ x, y ] ) || 
          collides( levels[ currentLevel ][ FLOORS ], [ x, y ] )

        /*
          A wall - # - is just an absence of anything else
        */
        c.fillText( 
          current ? current[ CHAR ] : CHAR_WALL, vX * textSize, vY * textSize 
        )
      }
    }
    c.fillText( 'L ' + currentLevel + ' HP ' + player[ HP ], 0, viewSize * textSize )
  }

  /*
    Movement for both payers and monsters
  */
  let move = ( mob, direction ) => {    
    /*
      set the position we're going to move to to the position we're already at
    */
    let targetPoint = [ mob[ X ], mob[ Y ] ]

    /*
      Monsters, one in five chance doesn't move towards player, otherwise try to
      move closer - the if/else structure here creates very predictable movement
      but is also very cheap - the chance not to move towards player helps to
      stop monsters getting permanently stuck
    */
    if( mob[ TILE_TYPE ] === TILE_TYPE_MONSTER && randInt( 5 ) ){
      if( player[ X ] < mob[ X ] ){
        targetPoint[ X ]--
      } 
      else if( player[ X ] > mob[ X ] ){
        targetPoint[ X ]++
      } 
      else if( player[ Y ] < mob[ Y ] ){
        targetPoint[ Y ]--        
      } 
      else if( player[ Y ] > mob[ Y ] ){
        targetPoint[ Y ]++
      }
    } else {
      /*
        This block is for the player, or for monsters who are moving randomly
        it saves bytes
      */

      //up
      if( direction === 1 ){
        targetPoint[ Y ]--
      } 
      //right
      else if( direction === 2 ){
        targetPoint[ X ]++
      } 
      //down
      else if( direction === 3 ){
        targetPoint[ Y ]++
      } 
      //left
      else if( direction === 0 ){
        targetPoint[ X ]--
      }
    }
    
    /*
      See if anything is at the point we tried to move to
    */
    let currentTile = collides( levels[ currentLevel ][ MOBS ], targetPoint )

    /*
      If we're a monster and the tile we tried to move to has a player on it,
      try to hit them instead of moving there
    */
    if( 
      currentTile && mob[ TILE_TYPE ] === TILE_TYPE_MONSTER && 
      currentTile[ TILE_TYPE ] === TILE_TYPE_PLAYER && randInt( 2 ) 
    ){
      currentTile[ HP ]--
    } 
    /*
      Ditto for player moving onto monster
    */
    else if( 
      currentTile && mob[ TILE_TYPE ] === TILE_TYPE_PLAYER && 
      currentTile[ TILE_TYPE ] === TILE_TYPE_MONSTER && randInt( 2 ) 
    ){
      currentTile[ HP ]--
    }
    /*
      Go down stairs
    */
    else if( currentTile && currentTile[ TILE_TYPE ] === TILE_TYPE_STAIRS_DOWN ){
      currentLevel++
      Dungeon()
    }
    /*
      If this is a floor tile and no mobs were here, we can move
    */
    else if( 
      collides( levels[ currentLevel ][ FLOORS ], targetPoint ) && !currentTile 
    ){
      mob[ X ] = targetPoint[ X ]
      mob[ Y ] = targetPoint[ Y ]
    } 
  }
  
  b.onkeydown = e => {
    /*
      Player moves first, slight advantage
    */
    move( player, e.which - 37 )
    
    /*
      Search the mobs for monsters, try to randomly move any that aren't dead
      Monsters prefer to move towards player but there's a chance they'll use
      this passed in random "keycode" instead
    */
    for( let i = 0; i < levels[ currentLevel ][ MOBS ].length; i++ ){
      if( 
        levels[ currentLevel ][ MOBS ][ i ][ HP ] && 
        levels[ currentLevel ][ MOBS ][ i ][ TILE_TYPE ] === TILE_TYPE_MONSTER 
      ) move( levels[ currentLevel ][ MOBS ][ i ], randInt( 4 ) )
    }

    /*
      Stop drawing when the player dies, game over - we're not communicating 
      well here but it's so cheap. If we have room later a message would be
      better
    */
    if( player[ HP ] > 0 ){
      draw()
    }  

    /*
    consider adding chance to spawn a monster on movement
    */
  }

  Dungeon()
  draw()    
}

G()  </script>
    <script>
      (function(){var doc=document;var header=doc.getElementsByTagName("header")[0];var firstChild=header.firstChild;var p=doc.getElementsByClassName("p")[0];
      var n=doc.getElementsByClassName("n")[0];header.insertBefore(p,firstChild);header.insertBefore(n,firstChild);header.appendChild(doc.getElementsByTagName
      ("p")[0])})();(function reload(fullscreen){var doc=document;var header=doc.getElementsByTagName("header")[0];var iframe=doc.createElement("iframe");doc.
      body.appendChild(iframe);var iwin=iframe.contentWindow;var idoc=iframe.contentDocument;idoc.open();idoc.close();idoc.write("<!doctype html>"+'<html st'+
      'yle="margin: 0; padding: 0; border: 0;'+(TOKEN_CANVAS_SHIM?' width: 100%; height: 100%;':'')+'">'+"<head>"+'<meta charset="utf-8">'+'<body style="mar'+
      'gin: 0; padding: 0; border: 0;'+(TOKEN_CANVAS_SHIM?' width: 100%; height: 100%;':'')+'">'+(TOKEN_CANVAS_SHIM?'<canvas style="display: block;'+(
      TOKEN_CENTER_CANVAS?" margin: auto;":"")+'"></canvas>':"")+"");if(TOKEN_CANVAS_SHIM){var canvas=idoc.getElementsByTagName("canvas")[0];var cs=canvas.style
      ;idoc.body.clientWidth;cs.width=(canvas.width=Math.max(Math.min(TOKEN_MAX_WIDTH||innerWidth,innerWidth),0)||0)+"px";cs.height=(canvas.height=Math.max(
      Math.min(TOKEN_MAX_HEIGHT||innerHeight-50,innerHeight-50),0)||0)+"px"}if(TOKEN_RELOAD_ONORIENTATIONCHANGE)onorientationchange=reloadClick;iwin.AudioContext
      =iwin.AudioContext||iwin.webkitAudioContext;iwin.requestAnimationFrame=iwin.requestAnimationFrame||iwin.mozRequestAnimationFrame||iwin.
      webkitRequestAnimationFrame||iwin.msRequestAnimationFrame||function(f){iwin.setTimeout(f,1E3/30)};if(TOKEN_CANVAS_SHIM)canvas.requestPointerLock=canvas.
      requestPointerLock||canvas.mozRequestPointerLock||canvas.webkitRequestPointerLock;idoc.body.requestPointerLock=idoc.body.requestPointerLock||idoc.body.
      mozRequestPointerLock||idoc.body.webkitRequestPointerLock;navigator.getUserMedia=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.
      mozGetUserMedia||navigator.msGetUserMedia;var iwo=iwin.OscillatorNode&&iwin.OscillatorNode.prototype;iwo&&(iwo.start=iwo.start||iwo.noteOn)&&(iwo.stop=iwo
      .stop||iwo.noteOff);if(TOKEN_CANVAS_SHIM)iwin.a=canvas;iwin.b=idoc.body;d=idoc;if(TOKEN_CANVAS_SHIM){if(!TOKEN_WEBGL)iwin.c=canvas.getContext("2d");if(
      TOKEN_WEBGL)iwin.g=function(){iwin.onorientationchange=iwin.onresize=null;try{var o={antialias:true,stencil:true};var gl=canvas.getContext("webgl",o)||
      canvas.getContext("experimental-webgl",o);iwin.__glExts=["OES_texture_float","OES_texture_float_linear","OES_standard_derivatives","EXT_texture_filter_"+
      "anisotropic","MOZ_EXT_texture_filter_anisotropic","WEBKIT_EXT_texture_filter_anisotropic","WEBGL_compressed_texture_s3tc","MOZ_WEBGL_compressed_textur"+
      "e_s3tc","WEBKIT_WEBGL_compressed_texture_s3tc"].map(function(ext){return gl.getExtension(ext)})}catch(e){idoc.body.innerHTML="WebGL not supported.";iwin
      .a=iwin.b=iwin.c=iwin.d=null;throw e;}return gl}()}var demo=idoc.createElement("script");demo.textContent=doc.querySelector('script[type="demo"]').
      textContent;idoc.body.appendChild(demo);idoc.close();iframe.contentWindow.focus();var firstLine=doc.getElementsByTagName("div")[0];function reloadClick(b)
      {doc.body.removeChild(iframe);r.parentElement.removeChild(r);iframe=null;r=null;idoc=null;header=null;reload(b)}window.reload=reloadClick;var r=doc.
      createElement("div");r.innerHTML="&#8635;";r.className="button r";r.title="restart just the demo (local, without remote fetch)";r.onclick=reloadClick;
      header.insertBefore(r,firstLine)})();
    </script>
  </body>
</html>
